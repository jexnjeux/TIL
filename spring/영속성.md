# 영속성

## 영속성 컨텍스트 (Persistence Context)

- 엔티티 영구 저장 환경
- 엔티티 매니저가 엔티티를 저장하거나 조회하면, 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리
- 엔티티 매니저가 `persist()`를 사용하면 엔티티를 영속성 컨텍스트에 저장
- 하나의 엔티티 매니저가 하나의 영속성 컨텍스트를 생성 및 접근할 수도 있고, 여러 엔티티 매니저가 하나의 영속성 컨텍스트를 공유 가능

## 엔티티 생명주기

1. 비영속(new/transient)

- 영속성 컨텍스트와 관계가 없는 상태

2. 영속 (managed)

- 영속성 컨텍스트에 저장된 상태

3. 준영속 (detached)

- 영속성 컨텍스트에 저장되어있따가 분리된 상태

4. 삭제 (removed)

- 삭제된 상태

![엔티티 생명주기](./image/엔티티%20생명주기.png)

## 영속성 컨텍스트 특징

- 엔티티를 식별자 값으로 구분하기 때문에 영속 상태는 반드시 식별자 값이 필요하다.
- JPA는 보통 트랜잭션을 커밋하는 순간 영속성 컨텍스트의 엔티티를 데이터베이스에 반영한다.
  - 이런 동작을 flush라고 함

## 영속성 컨텍스트가 엔티티를 관리할 떄 생기는 장점

- 1차 캐시
  - 영속성 상태 엔티티는 모두 여기에 저장
  - find() 1차적으로 캐시를 조회, 조회가 안되면 DB에서 조회
- 동일성 보장
  - 1차 캐시에 있는 같은 엔티티를 반환
- 트랜잭션을 지원하는 쓰기 지연
  - 트랜잭션을 commit 하기 전까지 엔티티를 저장하지 않고 내부 쿼리 저장소에 저장
  - commit할 때 한 번에 반영하기 때문에 IO가 줄어들어 효율적인 프로그래밍 가능
- 변경 감지
  - 엔티티를 영속성 컨텍스트에 보관할 때 snapshot을 함께 보관
  - flush 시점에 snapshot과 엔티티를 비교해서 수정된 부분을 db에 반영
- 지연로딩(Lazy loading)
  - 데이터가 실제로 사용되는 떄에 가지고 옴

## flush

영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.

### flush 수행 시 일어나는 일

1. 변경 감지가 동작하여 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교하여 변경이 있는 엔티티를 찾는다.
2. 변경이 있는 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.
3. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.

### 영속성 컨텍스트를 플러시 하는 방법

- em.flush() 직접 호출
- 트랜잭션 커밋 시 자동 호출
- JPQL 쿼리 실행 시 자동 호출
